// Generated by CoffeeScript 1.9.3
(function() {
  var connections, generateClientId, getEmitTopic;

  angular.module('ngMqtt', []).provider('mqtt', [
    '$windowProvider', '$rootScopeProvider', function($windowProvider, $rootScopeProvider) {
      var $rootScope, _namespace, client, generateClientId;
      $rootScope = $rootScopeProvider.$get[$rootScopeProvider.$get.length - 1]();
      _namespace = '';
      this.namespace = {
        getter: function() {
          return _namespace;
        },
        setter: function(value) {
          return _namespace = value;
        }
      };
      client = void 0;
      generateClientId = function() {
        var i, length, possible, text;
        length = 10;
        possible = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
        text = ((function() {
          var j, ref, results;
          results = [];
          for (i = j = 1, ref = length; 1 <= ref ? j < ref : j > ref; i = 1 <= ref ? ++j : --j) {
            results.push(possible.charAt(Math.floor(Math.random() * possible.length)));
          }
          return results;
        })()).join('');
        return 'websocket/' + text;
      };
      return {
        $get: function() {
          return {
            generateClientId: generateClientId,
            connect: function(opts) {
              console.log(opts);
              client = $windowProvider.$get().mqtt.connect({
                host: '127.0.0.1',
                port: 1883,
                path: '/mqtt'
              });
              client.on('connect', function() {
                client.subscribe('presence');
                return client.publish('presence', 'Hello mqtt');
              });
              return client.on('message', function(topic, message) {
                console.log(message.toString());
                return client.end();
              });
            }
          };
        }
      };
    }
  ]).config([
    'mqttProvider', function(mqttProvider) {
      return mqttProvider.namespace = 'my';
    }
  ]).controller('ctrl', [
    '$scope', 'mqtt', function($scope, mqtt) {
      return mqtt.connect({
        broker: 'broker.mqttdashboard.com',
        port: 8000,
        username: '',
        password: '',
        useSSL: false,
        keepalive: 30,
        timeout: 10,
        mqttVersion: 3.1,
        cleanSession: true
      });
    }
  ]);

  angular.module('ng-mqtt', []).factory('mqtt', [
    '$window', function($window) {}, connections = {}, generateClientId = function() {
      var i, length, possible, text;
      text = '';
      length = 10;
      possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
      text = ((function() {
        var j, ref, results;
        results = [];
        for (i = j = 1, ref = length; 1 <= ref ? j < ref : j > ref; i = 1 <= ref ? ++j : --j) {
          results.push(possible.charAt(Math.floor(Math.random() * possible.length)));
        }
        return results;
      })())(reduce(function(x, y) {
        return x + y;
      }));
      return 'WEBSOCKET/'.concat(text);
    }, getEmitTopic = function(event, id) {
      return 'ThingFabricMqttWebSocketService'.concat(':').concat(event).concat(':').concat(id);
    }, {
      connect: function(scope, opts) {
        var client;
        console.log(opts);
        connections[opts.connectionId] = {
          opts: opts,
          scope: scope
        };
        client = new $window.Paho.MQTT.Client(String(ThingFabricConstants.mqttws.broker), Number(ThingFabricConstants.mqttws.port), generateClientId());
        connections[opts.connectionId].client = client;
        client.onConnectionLost = function(resp) {
          if (scope) {
            if (typeof scope === 'function') {
              return scope(getEmitTopic('connectionLost', opts.connectionId), resp);
            }
            return scope.$emit(getEmitTopic('connectionLost', opts.connectionId), resp);
          }
        };
        client.onMessageArrived = function(message) {
          if (scope) {
            if (typeof scope === 'function') {
              return scope(getEmitTopic('messageArrived', opts.connectionId), resp);
            }
            return scope.$emit(getEmitTopic('messageArrived', opts.connectionId), message);
          }
        };
        return client.connect({
          userName: opts.username,
          password: opts.password,
          useSSL: ThingFabricConstants.mqttws.useSSL,
          keepAliveInterval: opts.keepAliveInterval || ThingFabricConstants.mqttws.keepAliveInterval,
          onSuccess: function(resp) {
            console.log('Sucessfully made MqttWS connection for ID %s', opts.connectionId);
            if (scope) {
              if (typeof scope === 'function') {
                return scope(getEmitTopic('onSuccess', opts.connectionId), {
                  connectionId: opts.connectionId
                });
              }
              return scope.$emit(getEmitTopic('onSuccess', opts.connectionId), {
                connectionId: opts.connectionId
              });
            }
          },
          onFailure: function(resp) {
            var plan, planName;
            console.log('Failed to make MqttWS connection!');
            console.log(resp);
            delete connections[opts.connectionId];
            if (resp.errorCode && (resp.errorCode === 5 || resp.errorCode === 6)) {
              console.log('Determining root cause of banning for Project %s!', $sanitize($routeParams.project_id));
              delete $rootScope.bannedModalText;
              ThingFabricProjectsResource.show({
                project_id: $sanitize($routeParams.project_id),
                resources: []
              }).then(function(resp) {});
              if (resp.status !== ThingFabricMessageService.jsend.SUCCESS) {
                return $rootScope.showBannedModal = true;
              }
              console.log('Plan is %s', resp.data.plan);
              planName = resp.data.plan;
              plan = _.findWhere(ThingFabricConstants.plans, {
                name: planName
              });
              ThingFabricProjectDevicesResource.showMonthlyBillableCount({
                project_id: $sanitize($routeParams.project_id)
              }).then(function(resp) {
                var isWithinHour;
                if (resp.status !== ThingFabricMessageService.jsend.SUCCESS) {
                  return $rootScope.showBannedModal = true;
                }
                if (resp.data.count >= plan.max_devices) {
                  console.log('%s is >= %s', resp.data.count, plan.max_devices);
                  $rootScope.bannedModalText = 1;
                  return $rootScope.showBannedModal = true;
                }
                ThingFabricProjectDevicesResource.present({
                  project_id: $sanitize($routeParams.project_id),
                  stuff: '$SYS',
                  thing: 'bans'
                }).then(function(resp) {});
                isWithinHour = function(clock) {
                  var difference, now;
                  clock = parseInt(clock.toString().substring(0, 13));
                  now = (new Date).getTime();
                  console.log('Is clock %s within hour of %s', clock, now);
                  difference = (now - clock) / 1000 / 60;
                  console.log('Difference is %s minutes', difference);
                  if (difference <= 60) {
                    return true;
                  }
                  return false;
                };
                if (resp.status !== ThingFabricMessageService.jsend.SUCCESS) {
                  return $rootScope.showBannedModal = true;
                }
                if (resp.data.whatevers['sent:rate:count'] && parseInt(resp.data.whatevers['sent:rate:count'].attributes.qos1) > parseInt(resp.data.whatevers['sent:limit:count'].attributes.qos1) && isWithinHour(parseInt(resp.data.whatevers['sent:rate:count'].attributes['qos1:clock']))) {
                  $rootScope.bannedModalText = 2;
                  return $rootScope.showBannedModal = true;
                }
                if (resp.data.whatevers['sent:rate:count'] && parseInt(resp.data.whatevers['sent:rate:count'].attributes.qos2) > parseInt(resp.data.whatevers['sent:limit:count'].attributes.qos2) && isWithinHour(parseInt(resp.data.whatevers['sent:rate:count'].attributes['qos2:clock']))) {
                  $rootScope.bannedModalText = 3;
                  return $rootScope.showBannedModal = true;
                }
                $rootScope.bannedModalText = 4;
                return $rootScope.showBannedModal = true;
              });
              return;
            }
            if (scope) {
              if (typeof scope === 'function') {
                return scope(getEmitTopic('onFailure', opts.connectionId), resp);
              }
              return scope.$emit(getEmitTopic('onFailure', opts.connectionId), resp);
            }
          }
        });
      },
      disconnect: function(passedConnectionId) {
        var error;
        console.log('Disconnecting MqttWS connection for ID %s', passedConnectionId);
        try {
          connections[passedConnectionId].client.disconnect();
          return delete connections[passedConnectionId];
        } catch (_error) {
          error = _error;
          return console.log('MqttWS disconnect error');
        }
      },
      addLastWillMessage: function(passedConnectionId, opts) {
        var message;
        message = new $window.Paho.MQTT.Message(opts.payload);
        message.qos = opts.qos || 0;
        message.destinationName = opts.topic;
        message.retained = opts.retain || false;
        return connections[passedConnectionId].client.willMessage = message;
      },
      subscribe: function(passedConnectionId, opts) {
        return connections[passedConnectionId].client.subscribe(opts.topic, {
          qos: opts.qos || 0
        });
      },
      unsubscribe: function(passedConnectionId, opts) {
        return connections[passedConnectionId].client.unsubscribe(opts.topic);
      },
      publish: function(passedConnectionId, opts) {
        var message;
        message = new $window.Paho.MQTT.Message(opts.payload);
        message.destinationName = opts.topic;
        message.qos = Number(opts.qos || 0);
        message.retained = opts.retain || false;
        return connections[passedConnectionId].client.send(message);
      }
    }
  ]);

}).call(this);
