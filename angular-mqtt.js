// Generated by CoffeeScript 1.9.3
(function() {
  var connections, generateClientId, getEmitTopic;

  angular.module('ngMqtt', []).provider('mqtt', [
    function() {
      var KEYWORD_STYLE, MSG_STYLE, NS_STYLE, TOPIC_STYLE, _namespace, connections, generateClientId, mqtt;
      _namespace = '';
      NS_STYLE = 'font-size: 13px; font-weight: bold; color: #606;';
      TOPIC_STYLE = 'font-size: 13px;';
      MSG_STYLE = 'font-size: 12px; font-style: italic; color: #777;';
      KEYWORD_STYLE = 'font-size: 13px; color: #008;';
      generateClientId = function() {
        var i, length, possible, text;
        length = 10;
        possible = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
        text = ((function() {
          var j, ref, results;
          results = [];
          for (i = j = 1, ref = length; 1 <= ref ? j < ref : j > ref; i = 1 <= ref ? ++j : --j) {
            results.push(possible.charAt(Math.floor(Math.random() * possible.length)));
          }
          return results;
        })()).join('');
        return 'websocket/' + text;
      };
      connections = [];
      mqtt = {
        $get: [
          '$window', '$rootScope', '$q', function($window, $rootScope, $q) {
            return {
              generateClientId: generateClientId,
              connect: function(opts) {
                var client;
                opts = opts || {};
                if (typeof opts.clientId === 'undefined') {
                  opts.clientId = generateClientId();
                }
                console.log(opts);
                client = $window.mqtt.connect(opts);
                client.on('message', function(topic, message) {
                  console.log('%c%s %ctopic:%c%s %cmessage:%c%s', NS_STYLE, _namespace, KEYWORD_STYLE, TOPIC_STYLE, topic, KEYWORD_STYLE, MSG_STYLE, message.toString());
                  return $rootScope.$broadcast(_namespace + ':' + topic, message.toString());
                });
                return $q(function(resolve, reject) {
                  client.on('connect', function() {
                    connections.push(client);
                    return resolve(connections.length - 1);
                  });
                  return client.on('error', reject);
                });
              },
              publish: function(id, topic, message) {
                if (connections[id] && connections[id].connected) {
                  return connections[id].publish(topic, message);
                } else {
                  throw new Error('not connected');
                }
              },
              subscribe: function(id, topic) {
                if (connections[id] && connections[id].connected) {
                  return connections[id].subscribe(topic);
                } else {
                  throw new Error('not connected');
                }
              },
              unsubscribe: function(id, topic) {
                if (connections[id] && connections[id].connected) {
                  return connections[id].unsubscribe(topic);
                } else {
                  throw new Error('not connected');
                }
              },
              disconnect: function(id) {
                if (connections[id] && connections[id].connected) {
                  throw new Error('not connected');
                } else {
                  return connections[id].end();
                }
              }
            };
          }
        ]
      };
      Object.defineProperty(mqtt, 'namespace', {
        get: function() {
          return _namespace;
        },
        set: function(value) {
          return _namespace = value;
        }
      });
      return mqtt;
    }
  ]).config([
    'mqttProvider', function(mqttProvider) {
      return mqttProvider.namespace = 'my';
    }
  ]).controller('ctrl', [
    '$scope', 'mqtt', function($scope, mqtt) {
      $scope.$on('my:wavocnvukgsu72j/test/angular-mqtt', function(event, msg) {
        return console.log('on : %s', msg);
      });
      return mqtt.connect({
        clientId: 'test/angular-mqtt',
        host: 'q.m2m.io',
        port: 4483,
        path: '/mqtt',
        username: '51c44d54-3844-4fe2-9b6c-5547996de838',
        password: '42ed45f7144c9b1757ce1c38f45d7120',
        useSSL: true,
        protocol: 'wss',
        keepalive: 30,
        timeout: 10,
        mqttVersion: 3.1,
        cleanSession: true
      }).then(function(id) {
        mqtt.subscribe(id, 'wavocnvukgsu72j/test/angular-mqtt');
        return mqtt.publish(id, 'wavocnvukgsu72j/test/angular-mqtt', 'hello world');
      }, function(error) {
        return console.error(error);
      });
    }
  ]);

  angular.module('ng-mqtt', []).factory('mqtt', [
    '$window', function($window) {}, connections = {}, generateClientId = function() {
      var i, length, possible, text;
      text = '';
      length = 10;
      possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
      text = ((function() {
        var j, ref, results;
        results = [];
        for (i = j = 1, ref = length; 1 <= ref ? j < ref : j > ref; i = 1 <= ref ? ++j : --j) {
          results.push(possible.charAt(Math.floor(Math.random() * possible.length)));
        }
        return results;
      })())(reduce(function(x, y) {
        return x + y;
      }));
      return 'WEBSOCKET/'.concat(text);
    }, getEmitTopic = function(event, id) {
      return 'ThingFabricMqttWebSocketService'.concat(':').concat(event).concat(':').concat(id);
    }, {
      connect: function(scope, opts) {
        var client;
        console.log(opts);
        connections[opts.connectionId] = {
          opts: opts,
          scope: scope
        };
        client = new $window.Paho.MQTT.Client(String(ThingFabricConstants.mqttws.broker), Number(ThingFabricConstants.mqttws.port), generateClientId());
        connections[opts.connectionId].client = client;
        client.onConnectionLost = function(resp) {
          if (scope) {
            if (typeof scope === 'function') {
              return scope(getEmitTopic('connectionLost', opts.connectionId), resp);
            }
            return scope.$emit(getEmitTopic('connectionLost', opts.connectionId), resp);
          }
        };
        client.onMessageArrived = function(message) {
          if (scope) {
            if (typeof scope === 'function') {
              return scope(getEmitTopic('messageArrived', opts.connectionId), resp);
            }
            return scope.$emit(getEmitTopic('messageArrived', opts.connectionId), message);
          }
        };
        return client.connect({
          userName: opts.username,
          password: opts.password,
          useSSL: ThingFabricConstants.mqttws.useSSL,
          keepAliveInterval: opts.keepAliveInterval || ThingFabricConstants.mqttws.keepAliveInterval,
          onSuccess: function(resp) {
            console.log('Sucessfully made MqttWS connection for ID %s', opts.connectionId);
            if (scope) {
              if (typeof scope === 'function') {
                return scope(getEmitTopic('onSuccess', opts.connectionId), {
                  connectionId: opts.connectionId
                });
              }
              return scope.$emit(getEmitTopic('onSuccess', opts.connectionId), {
                connectionId: opts.connectionId
              });
            }
          },
          onFailure: function(resp) {
            var plan, planName;
            console.log('Failed to make MqttWS connection!');
            console.log(resp);
            delete connections[opts.connectionId];
            if (resp.errorCode && (resp.errorCode === 5 || resp.errorCode === 6)) {
              console.log('Determining root cause of banning for Project %s!', $sanitize($routeParams.project_id));
              delete $rootScope.bannedModalText;
              ThingFabricProjectsResource.show({
                project_id: $sanitize($routeParams.project_id),
                resources: []
              }).then(function(resp) {});
              if (resp.status !== ThingFabricMessageService.jsend.SUCCESS) {
                return $rootScope.showBannedModal = true;
              }
              console.log('Plan is %s', resp.data.plan);
              planName = resp.data.plan;
              plan = _.findWhere(ThingFabricConstants.plans, {
                name: planName
              });
              ThingFabricProjectDevicesResource.showMonthlyBillableCount({
                project_id: $sanitize($routeParams.project_id)
              }).then(function(resp) {
                var isWithinHour;
                if (resp.status !== ThingFabricMessageService.jsend.SUCCESS) {
                  return $rootScope.showBannedModal = true;
                }
                if (resp.data.count >= plan.max_devices) {
                  console.log('%s is >= %s', resp.data.count, plan.max_devices);
                  $rootScope.bannedModalText = 1;
                  return $rootScope.showBannedModal = true;
                }
                ThingFabricProjectDevicesResource.present({
                  project_id: $sanitize($routeParams.project_id),
                  stuff: '$SYS',
                  thing: 'bans'
                }).then(function(resp) {});
                isWithinHour = function(clock) {
                  var difference, now;
                  clock = parseInt(clock.toString().substring(0, 13));
                  now = (new Date).getTime();
                  console.log('Is clock %s within hour of %s', clock, now);
                  difference = (now - clock) / 1000 / 60;
                  console.log('Difference is %s minutes', difference);
                  if (difference <= 60) {
                    return true;
                  }
                  return false;
                };
                if (resp.status !== ThingFabricMessageService.jsend.SUCCESS) {
                  return $rootScope.showBannedModal = true;
                }
                if (resp.data.whatevers['sent:rate:count'] && parseInt(resp.data.whatevers['sent:rate:count'].attributes.qos1) > parseInt(resp.data.whatevers['sent:limit:count'].attributes.qos1) && isWithinHour(parseInt(resp.data.whatevers['sent:rate:count'].attributes['qos1:clock']))) {
                  $rootScope.bannedModalText = 2;
                  return $rootScope.showBannedModal = true;
                }
                if (resp.data.whatevers['sent:rate:count'] && parseInt(resp.data.whatevers['sent:rate:count'].attributes.qos2) > parseInt(resp.data.whatevers['sent:limit:count'].attributes.qos2) && isWithinHour(parseInt(resp.data.whatevers['sent:rate:count'].attributes['qos2:clock']))) {
                  $rootScope.bannedModalText = 3;
                  return $rootScope.showBannedModal = true;
                }
                $rootScope.bannedModalText = 4;
                return $rootScope.showBannedModal = true;
              });
              return;
            }
            if (scope) {
              if (typeof scope === 'function') {
                return scope(getEmitTopic('onFailure', opts.connectionId), resp);
              }
              return scope.$emit(getEmitTopic('onFailure', opts.connectionId), resp);
            }
          }
        });
      },
      disconnect: function(passedConnectionId) {
        var error;
        console.log('Disconnecting MqttWS connection for ID %s', passedConnectionId);
        try {
          connections[passedConnectionId].client.disconnect();
          return delete connections[passedConnectionId];
        } catch (_error) {
          error = _error;
          return console.log('MqttWS disconnect error');
        }
      },
      addLastWillMessage: function(passedConnectionId, opts) {
        var message;
        message = new $window.Paho.MQTT.Message(opts.payload);
        message.qos = opts.qos || 0;
        message.destinationName = opts.topic;
        message.retained = opts.retain || false;
        return connections[passedConnectionId].client.willMessage = message;
      },
      subscribe: function(passedConnectionId, opts) {
        return connections[passedConnectionId].client.subscribe(opts.topic, {
          qos: opts.qos || 0
        });
      },
      unsubscribe: function(passedConnectionId, opts) {
        return connections[passedConnectionId].client.unsubscribe(opts.topic);
      },
      publish: function(passedConnectionId, opts) {
        var message;
        message = new $window.Paho.MQTT.Message(opts.payload);
        message.destinationName = opts.topic;
        message.qos = Number(opts.qos || 0);
        message.retained = opts.retain || false;
        return connections[passedConnectionId].client.send(message);
      }
    }
  ]);

}).call(this);
